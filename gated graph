import tensorflow as tf
from tensorflow.keras.layers import Layer, Dense
from tensorflow.keras import Model

class GatedGraphUnit(Layer):
    def __init__(self, units):
        super(GatedGraphUnit, self).__init__()
        self.units = units
        self.dense_z = Dense(units, activation='sigmoid')
        self.dense_r = Dense(units, activation='sigmoid')
        self.dense_h = Dense(units, activation='tanh')

    def call(self, x, adj):
        # x: Node features [batch_size, num_nodes, feature_dim]
        # adj: Adjacency matrix [batch_size, num_nodes, num_nodes]
        
        # Update gate
        z = self.dense_z(x)
        
        # Reset gate
        r = self.dense_r(x)
        
        # Candidate hidden state
        h_tilde = self.dense_h(tf.matmul(adj, r * x))
        
        # New hidden state
        h = (1 - z) * x + z * h_tilde
        
        return h

class GatedGraphSequenceNN(Model):
    def __init__(self, input_dim, hidden_dim, output_dim, num_layers):
        super(GatedGraphSequenceNN, self).__init__()
        self.num_layers = num_layers
        self.ggus = [GatedGraphUnit(hidden_dim) for _ in range(num_layers)]
        self.dense_out = Dense(output_dim)

    def call(self, x, adj):
        for i in range(self.num_layers):
            x = self.ggus[i](x, adj)
        output = self.dense_out(x)
        return output

# Example usage
if __name__ == "__main__":
    # Sample data
    batch_size = 1
    num_nodes = 3
    feature_dim = 4
    hidden_dim = 8
    output_dim = 2
    num_layers = 2

    # Node features: [batch_size, num_nodes, feature_dim]
    node_features = tf.random.uniform((batch_size, num_nodes, feature_dim))

    # Adjacency matrix: [batch_size, num_nodes, num_nodes]
    adj_matrix = tf.constant([[[1, 1, 0], [1, 1, 1], [0, 1, 1]]], dtype=tf.float32)

    # Model
    model = GatedGraphSequenceNN(input_dim=feature_dim, hidden_dim=hidden_dim, output_dim=output_dim, num_layers=num_layers)

    # Forward pass
    output = model(node_features, adj_matrix)
    print(output)
